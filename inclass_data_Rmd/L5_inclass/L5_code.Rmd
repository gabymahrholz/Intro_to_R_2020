---
title: "L5_code"
author: "GM"
date: "7 February 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Pre-steps

Load `tidyverse` into the library.

```{r}
library(tidyverse)
```


## Tidy data

There are three interrelated rules which make a dataset tidy:

1. Each variable must have its own column.
2. Each observation must have its own row.
3. Each value must have its own cell.

Most data is not in a tidy format.

## gather()

`table1` has a tidy structure.

```{r}
table1
```

`table4a` does not have a tidy structure.

```{r}
table4a
```


We can use gather() to get `table 4a` into a tidy structure


```{r}
gather(table4a, key = year, value = cases, `1999`:`2000`)
```


**Your turn**

Look at `table4b`. 

```{r}
table4b
```


There are two separate columns `1999` and `2000` with population values for Afghanistan, Brazil, and China. Use the `gather()` function on `table4b` to reshape it from wide format into long format.


```{r}
gather(NULL)
```



### spread()

Let's take a look at `table2`.

```{r}
table2
```

`table2` is not in a tidy format either. The variables `cases` and `population` are stored in one column `type` and their respective values in `count`. However, `cases` and `population` are separate variables rather than values of `type`. So best to get them spread out into their own columns as shown in the image below.



```{r}
spread(table2, key = type, value = count)
```

Voila, `cases` and `population` are in their own columns.



Let me modify `table1` a tiny bit for the next task.

```{r}
table1_mod <- table1 %>% 
  mutate(percent = cases/ population * 100) %>% 
  gather(variable, values, cases:percent)

table1_mod
```


**Your turn**

In the modified table above `table1_mod`, we added a `percent` column to see how much percentage of the population had Tuberculosis in 1999 and 2000 in each of the countries Afghanistan, Brazil, and China. But somehow, all numerical information has ended up in 1 column (values).

Your task is to spread the data back out, so that cases, population, and percentage values are in their own columns, titled as `cases`, `population`, and `percent` respectively. Store the new object in the `Global Environment` as `table1_mod_corrected`. When you are done, `table1_mod_corrected` should look like this...


```{r}
table1_mod_corrected <- NULL
```



## separate() 

Take a look at `table3`. 

```{r}
table3
```

In `table3`, two out of three principles of tidy data are violated. There are multiple values stored in column `rate` (rule 3) but these multiple values also belong to two different variables - `cases` and `population` respectively (rule 1).

We would use `separate()` to split the column `rate` into two columns `cases` and `population`. 


```{r}
separate(table3, rate, into = c("cases", "population"), sep = "/")
```


### additional arguments for separate()

#### Retaining the original column

If for some reason, you wanted to keep the original column, you can set an additional argument `remove` to `FALSE`.

```{r}
separate(table3, rate, into = c("cases", "population"), sep = "/", remove = FALSE)
```

#### Dropping parts of the original column

What if we were just interested retaining part of the data in the cell, for example keeping the column `cases` but not `population`. The solution would be to work with an `NA` argument. Defining the new columns as `cases` and `NA` will keep everything before the separator in the column `cases`, and drops everything after the separator.

```{r}
separate(table3, rate, into = c("cases", NA), sep = "/")
```



**Your turn**

Separate the column `rate` in `table3` to keep only the values after the separator in a column called `population`. Drop the values in front of the separator. Retain the column `rate` as well.


```{r}
separate(NULL)
```


#### Separating by position

It is also possible to separate by position. `sep = 2` would split the column between the second and third character/ number etc.

Let's try that the separation by position. We will keep 4 letters from each `country` name rather than the whole word, and drop the rest.

```{r}
separate(table3, country, into = c("country", NA), sep = 4)
```


#### Separating into more than 2 columns

Special case. Let's modify `table3` a little bit by adding a new column with a value of 200 and unite that column with column `rate`.

```{r}
table3_mod <- table3 %>% 
  mutate(new = 200) %>% 
  unite(rate, rate, new, sep = "/")
```


Now column `rate` has 3 sets of numbers, separated by two `/`. Defining 2 columns only will drop all information after the second `/` with a warning.

```{r}
separate(table3_mod, rate, into = c("cases", "population"), sep = "/")
```



If we are separating the columns and wanted to keep all sets of numbers, one in each column, we would use an into argument that includes 3 new columns.

```{r}
separate(table3_mod, rate, into = c("cases", "population", "200"), sep = "/")
```



If the values in `population` and `200` (separated by a `/`) were some sort of `ID_code`, **AND** we wanted to split the data into 2 columns, after the first `/` only, we would have to include an `extra` argument, and set it to `"merge"`.

```{r}
separate(table3_mod, rate, into = c("cases", "ID_code"), sep = "/", extra = "merge")
```


**Question Time**
There is still a tiny bit off in the `tb_cases`. Can you spot what it is? * Hint: Think about if you wanted to sum up all the TB cases occurred in the 3 countries within the years 1999, and 2000.

Answer:


How would you fix that?

```{r}
table3_mod %>% 
  NULL
```

`r unhide()`


#### Converting data types

The slightly quicker and perhaps more elegant solution would be to add another argument `convert` to `separate()` and set it to `TRUE`. 

```{r}
table3_mod %>% 
  separate(rate, into = c("cases", "ID_code"), sep = "/", extra = "merge", convert = TRUE)
```


### unite()

Take a look at `table5`. 

```{r}
table5
```


Here the values in column `year` are split into `century` and `year` which is not very useful. Best to merge the 2 columns together.


We would need the data `table5`, a new column we want to create `year`, the two columns we would like to combine (`century` and `year`), and define the separator as "nothing" since the default is sep = "_".

```{r}
unite(table5, year, century, year, sep = "")
```

Yay! The data of `table5` is in a tidier format now - at least for variable `year`.



**Your turn**

Let's combine the two steps of tidying `table5` in a single pipe `%>%` - separate the `rate` column into `cases` and `population`, and unite the columns `year` and `century` into a new column `year`. Store the new object as `tb_cases` in the `Global Environment`. Make sure, the columns `cases` and `population` are `integer` values.



```{r}
tb_cases <- NULL
```


`unite()` does not have a convert argument, so if we were to convert `year` into an `integer` variable, we would have to do that the "old-fashioned way".

```{r}
tb_cases_converted <- tb_cases %>% 
  mutate(year = as.integer(year))
tb_cases_converted
```


### additional arguments for unite()

#### Retaining the original column

Similarly to `separate()`, unite also comes with a remove statement, so if you wanted to keep the original columns before merging them together, you would code

```{r}
unite(table5, year_combined, century, year, sep = "", remove = FALSE)
```


#### Removing missing values before uniting columns

`unite()` also comes with an `na.rm` statement that will remove missing values prior to uniting the values of a column (actually, the values have to be a "character" column). Let me modify `table5` a wee bit to make that point.

```{r}
table5_mod <- table5 %>% 
  mutate(new = rep(c("200", NA), 3))

table5_mod
```

If we wanted to combine the values of `rate` and `new` in a new calumn called `rate`, we would code

```{r}
unite(table5_mod, rate, rate, new, sep = "/")
```

See how R adds the missing values onto rate, which we do not want. To avoid that happening, we can use the `na.rm` statement which removes missing values in columns of data type character before merging the columns.

```{r}
unite(table5_mod, rate, rate, new, sep = "/", na.rm = TRUE)
```


